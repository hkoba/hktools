#compdef -P (*/)#*.pm

# print "YESS, modulino!!, yess"
# print funcfiletrace ${(@q-)funcfiletrace}
# print funcsourcetrace ${(@q-)funcsourcetrace}

_perl_modulino_script_dir=${${${funcsourcetrace[1]}%:0}:a:h:h}
_perl_modulino_inspector=(
    perl -I$_perl_modulino_script_dir/
    $_perl_modulino_script_dir/MOP4Import/CLI/Completer.pm
    -0
    joined
)

function _perl_modulino_inspect {
    local method=$1 pmfile
    shift || return 1
    pmfile=$words[1]
    shift words || return 1
    # TODO: _call_program
    $_perl_modulino_inspector \
        $method \
        CURSOR $CURSOR \
        CURRENT $[CURRENT - 1] \
        NUMERIC "$NUMERIC" \
        pmfile $~pmfile \
        words \[${(j/,/)${(@qqq)words}}\] \
        BUFFER ${(q-)BUFFER} \
        "$@" || return $?
}

function _perl_modulino_is_completing_main_options {
    local argList
    argList=("$words[@]")
    shift argList
    local curPos=$[CURRENT-1]
    local methodPos=$argList[(ri)[a-z]*]
    if (($methodPos <= $#argList && $methodPos < $curPos)); then
        return 1
    fi
    [[ $argList[$curPos] = -* ]]
}

function _perl_modulino {
    integer ret=1
    # local curcontext=$curcontext state line
    # declare -A opt_args

    local debug=0
    if (($+DEBUG_ZSH_perl_modulino)) && ((DEBUG_ZSH_perl_modulino)); then
        debug=1
    fi

    if _perl_modulino_is_completing_main_options; then
        local modulino_opts
        if ((debug)); then set -x; fi
        modulino_opts=(${(0)"$(_perl_modulino_inspect zsh_options)"})
        if ((debug)); then set +x; fi

        _arguments : $modulino_opts && ret=0

        # _describe -t main_options "Main Options" modulino_opts && ret=0
        
    else
        local modulino_methods
        if ((debug)); then set -x; fi
        modulino_methods=(${(0)"$(_perl_modulino_inspect zsh_methods)"})
        if ((debug)); then set +x; fi

        _describe -t method "Methods" modulino_methods && ret=0
    fi

    return ret
}

_perl_modulino
